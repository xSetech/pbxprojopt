//! .pbxproj lexer derivation

use ansi_term::Style;
use pest::iterators::Pair;
use pest_derive::Parser as PestParser;

#[derive(PestParser)]
#[grammar = "pbxproj.pest"]
pub struct PBXProjLexer;

/// Recursively stylize tokens and matching rules from the lexer. Returns
/// whether the inner most token was reached. If 'buffer' is None, text will be
/// printed to stdout. If 'stylize' is true, ANSI color codes will be used.
///
pub fn visualize_matched_grammar_rule(
    pair: &Pair<Rule>,
    offset: usize,
    buffer: &mut Option<&mut String>,
    stylize: bool
) -> bool {

    let span = pair.clone().as_span();
    let inner_pairs = pair.clone().into_inner();

    // Format the rule name that generated the token and append the cursor
    // position if it's the inner-most token.
    let rule_name: String = format!("{:?}", pair.as_rule());
    let arrow: &str = if offset != 0 { "->" } else { "" };
    let position: String = if inner_pairs.len() == 0 {
        format!("<{},{}>", span.start(), span.end())
    } else { String::new() };

    let rule_name_style: Style;
    let location_style: Style;
    if stylize {
        rule_name_style = Style::new().bold();
        location_style = Style::new().dimmed();
    } else {
        rule_name_style = Style::new();
        location_style = Style::new();
    }

    let formatted = format!(
        "{}{}{}", arrow, rule_name_style.paint(&rule_name), location_style.paint(&position)
    );

    match buffer {
        Some(buf) => buf.push_str(formatted.as_str()),
        None => print!("{}", formatted),
    }

    // If the token is a leaf, also append the matching text
    // e.g. "File->LineComment->LineCommentValue: foo"
    //
    // If there is no matching text (e.g. EOI), a "$" is used in place of ": "
    if inner_pairs.len() == 0 {
        let span_value = format!("{}", span.as_str());
        let leaf_text: String = if span_value.is_empty() { String::from("$") } else {
            format!(": {}", span.as_str())
        };
        match buffer {
            Some(buf) => buf.push_str(leaf_text.as_str()),
            None => print!("{}", leaf_text),
        }
        return true;
    }

    // Format any inner rules/tokens
    let printed: usize = arrow.len() + rule_name.len() + position.len();
    let mut first: bool = true;
    for inner_pair in inner_pairs {

        // Vertically align inner tokens, e.g.
        // "File->LineComment->LineCommentValue: foo"
        // "    ->LineComment->LineCommentValue: bar"
        if first {
            first = false;
        } else {
            let indent = format!("{}", " ".repeat(printed + offset));
            match buffer {
                Some(buf) => buf.push_str(indent.as_str()),
                None => print!("{}", indent),
            }
        }

        let need_newline: bool = visualize_matched_grammar_rule(&inner_pair, printed + offset, buffer, stylize);
        if need_newline {
            match buffer {
                Some(buf) => buf.push_str("\n"),
                None => println!(""),
            }
        }
    }

    return false;
}

#[cfg(test)]
mod tests {
    use super::*;
    use pest::Parser as PestParser;

    #[allow(unused_imports)]
    use pretty_assertions::{assert_eq, assert_ne};

    /// Tests whether the given 'content' is parsable. Optionally compares the
    /// pairs returned from the lexer with the string that would be generated by
    /// the visualizer function (see above the tests).
    macro_rules! test_case_lexable {

        // Tests only whether the given 'content' is parsable.
        ($content:expr) => {{
            let r = PBXProjLexer::parse(
                Rule::File,
                $content,
            );
            r.unwrap();
        }};

        // Tests whether the result from lexing matches an expected string. For example,
        // "// foo" is expected to be visualized as "File->LineComment->LineCommentValue: foo"
        //
        // 'expected' is a Vec<&str>
        ($content:expr, $expected:expr) => {{
            let r = PBXProjLexer::parse(
                Rule::File,
                $content,
            );
            let mut pairs = r.unwrap();
            let pair = pairs.next().unwrap();  // only one (File) expected, enforced by the grammar
            let mut buffer = String::new();
            visualize_matched_grammar_rule(&pair, 0, &mut Some(&mut buffer), false);
            let lines: Vec<&str> = buffer.lines().collect();
            assert_eq!($expected, lines);
        }};

    }

    macro_rules! test_case_unlexable {
        ($content:expr) => {{
            let r = PBXProjLexer::parse(
                Rule::File,
                $content,
            );
            assert!(r.is_err());
        }};
    }

    /// Case:  An empty file is not parsable
    #[test]
    pub fn test_empty_file() {
        test_case_unlexable!("");
    }

    #[test]
    pub fn test_file_encoding() {
        test_case_lexable!(
            "// !$*UTF8*$!",
            vec![
                "File->Comment->LineComment->FileEncoding<6,10>: UTF8",
                "    ->EOI<13,13>$"
            ]
        );
    }

    #[test]
    pub fn test_comment_line() {
        test_case_lexable!(
            "//",
            vec![
                "File->Comment->LineComment<0,2>: //",
                "    ->EOI<2,2>$"
            ]
        );
        test_case_lexable!("//abc123");
        test_case_lexable!("// abc123");
        test_case_lexable!("// abc123 ");
        test_case_lexable!("// abc123 \n");
        test_case_lexable!("// abc123 \n// abc123 \n");
        test_case_lexable!(" // abc123 \n // abc123 \n");
        test_case_lexable!(
            "\n // abc123\n // abc123 \n",
            vec![
                "File->Comment->LineComment->LineCommentValue<5,11>: abc123",
                "    ->Comment->LineComment->LineCommentValue<16,23>: abc123 ",
                "    ->EOI<24,24>$"
            ]
        );
    }

    #[test]
    pub fn test_comment_block() {
        test_case_lexable!("/**/");
        test_case_lexable!("/*abc123*/");
        test_case_lexable!(
            "/* abc123 */",
            vec![
                "File->Comment->BlockComment->BlockCommentValue<3,9>: abc123",
                "    ->EOI<12,12>$"
            ]
        );
        test_case_lexable!("\n/* abc123 */\n");
        test_case_lexable!("/*\nabc123\n*/");
        test_case_lexable!("/*\n*/");
    }

    #[test]
    pub fn test_string_quoted() {
        test_case_lexable!("\"\"");
        test_case_lexable!(
            "\"abc123\"",
            vec![
                r#"File->String->QuotedString<1,7>: abc123"#,
                r#"    ->EOI<8,8>$"#
            ]
        );
        test_case_lexable!("\"!@#$%^&*()_+1234567890-={}[];':<>,./?`~\"");

        // Note, character escape is implemented in the parser
        test_case_lexable!("\"\t\n\r\"");
        test_case_lexable!("\"\\t\\n\\r\"");
        test_case_lexable!("\"\\\\\"");

        /*
            - No single quotes
            - No unescaped "\"
        */
        test_case_unlexable!("''");
        test_case_unlexable!("'a'");
        test_case_unlexable!("'abc123'");
        test_case_unlexable!("\"\\\"");
    }

    #[test]
    pub fn test_string_unquoted() {
        test_case_lexable!(
            "ABC123",
            vec![
                "File->String->UnquotedString<0,6>: ABC123",
                "    ->EOI<6,6>$"
            ]
        );
        test_case_lexable!("example.test");
        test_case_lexable!("/foo/bar/baz");
        test_case_lexable!("FOO_BAR_BAZ");
    }

    #[test]
    pub fn test_array() {
        test_case_lexable!("()");
        test_case_lexable!("( )");
        test_case_lexable!(" ( ) ");
        test_case_lexable!("(1)");
        test_case_lexable!("( 1 )");
        test_case_lexable!(
            "(1,2,3)",
            vec![
                "File->Array->ArrayEntry->String->UnquotedString<1,2>: 1",
                "           ->ArrayEntry->String->UnquotedString<3,4>: 2",
                "           ->ArrayEntry->String->UnquotedString<5,6>: 3",
                "    ->EOI<7,7>$"
            ]
        );
        test_case_lexable!("(1, 2, 3)");
        test_case_lexable!("( 1, 2, 3 )");
        test_case_lexable!("( \"1\", \"2\", \"3\" )");
        test_case_lexable!("( // \"1\", \"2\", \"3\" )\n1, 2, 3)");
        test_case_lexable!("( 1 /* a */, 2 /* a */, /* c */ 3 /* d */ )");
        test_case_lexable!("(1, 2, 3,)");
    }

    #[test]
    pub fn test_dictionary() {
        test_case_lexable!("{}");
        test_case_lexable!("{x=y;}");
        test_case_lexable!(
            "{x=y;a=b;}",
            vec![
                "File->Dictionary->DictEntry->DictKey->String->UnquotedString<1,2>: x",
                "                           ->DictVal->String->UnquotedString<3,4>: y",
                "                ->DictEntry->DictKey->String->UnquotedString<5,6>: a",
                "                           ->DictVal->String->UnquotedString<7,8>: b",
                "    ->EOI<10,10>$"
            ]
        );
        test_case_lexable!("{ x = y ; }");
        test_case_lexable!(r#"{ "x" = "y" ; }"#);
        test_case_lexable!(r#"{ "x" /* a */ = "y" /* b */ ; }"#);
        test_case_lexable!("{\nx = 1;\n}");
        test_case_lexable!("{ x = 1; /* test */ }");

        test_case_unlexable!("{;}");
        test_case_unlexable!("{x=}");
        test_case_unlexable!("{x=y}");
    }

    #[test]
    pub fn test_composite_objects() {
        test_case_lexable!("(())");
        test_case_lexable!("(1, 2, (3, 4))");
        test_case_lexable!("(1, 2, (3, {x = 1; y = 2;}))");
        test_case_lexable!(
            "{x = (1, 2); y = 3;}",
            vec![
                "File->Dictionary->DictEntry->DictKey->String->UnquotedString<1,2>: x",
                "                           ->DictVal->Array->ArrayEntry->String->UnquotedString<6,7>: 1",
                "                                           ->ArrayEntry->String->UnquotedString<9,10>: 2",
                "                ->DictEntry->DictKey->String->UnquotedString<13,14>: y",
                "                           ->DictVal->String->UnquotedString<17,18>: 3",
                "    ->EOI<20,20>$"
            ]
        );
        test_case_lexable!("{x = (); y = {z = 1;};}");
    }

}

// eof